{"ast":null,"code":"/*\n Highcharts JS v10.3.1 (2022-10-31)\n\n (c) 2017-2021 Highsoft AS\n Authors: Jon Arild Nygard\n\n License: www.highcharts.com/license\n*/\n(function (a) {\n  \"object\" === typeof module && module.exports ? (a[\"default\"] = a, module.exports = a) : \"function\" === typeof define && define.amd ? define(\"highcharts/modules/venn\", [\"highcharts\"], function (n) {\n    a(n);\n    a.Highcharts = n;\n    return a;\n  }) : a(\"undefined\" !== typeof Highcharts ? Highcharts : void 0);\n})(function (a) {\n  function n(a, d, b, A) {\n    a.hasOwnProperty(d) || (a[d] = A.apply(null, b), \"function\" === typeof CustomEvent && window.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: d,\n        module: a[d]\n      }\n    })));\n  }\n  a = a ? a._modules : {};\n  n(a, \"Core/Geometry/GeometryUtilities.js\", [], function () {\n    var a;\n    (function (a) {\n      a.getCenterOfPoints = function (a) {\n        var b = a.reduce(function (a, b) {\n          a.x += b.x;\n          a.y += b.y;\n          return a;\n        }, {\n          x: 0,\n          y: 0\n        });\n        return {\n          x: b.x / a.length,\n          y: b.y / a.length\n        };\n      };\n      a.getDistanceBetweenPoints = function (a, d) {\n        return Math.sqrt(Math.pow(d.x - a.x, 2) + Math.pow(d.y - a.y, 2));\n      };\n      a.getAngleBetweenPoints = function (a, d) {\n        return Math.atan2(d.x - a.x, d.y - a.y);\n      };\n    })(a || (a = {}));\n    return a;\n  });\n  n(a, \"Core/Geometry/CircleUtilities.js\", [a[\"Core/Geometry/GeometryUtilities.js\"]], function (a) {\n    var d = a.getAngleBetweenPoints,\n      b = a.getCenterOfPoints,\n      A = a.getDistanceBetweenPoints,\n      m;\n    (function (a) {\n      function l(a, f) {\n        f = Math.pow(10, f);\n        return Math.round(a * f) / f;\n      }\n      function q(a) {\n        if (0 >= a) throw Error(\"radius of circle must be a positive number.\");\n        return Math.PI * a * a;\n      }\n      function h(a, f) {\n        return a * a * Math.acos(1 - f / a) - (a - f) * Math.sqrt(f * (2 * a - f));\n      }\n      function k(a, f) {\n        var b = A(a, f),\n          d = a.r,\n          p = f.r,\n          h = [];\n        if (b < d + p && b > Math.abs(d - p)) {\n          d *= d;\n          var r = (d - p * p + b * b) / (2 * b);\n          p = Math.sqrt(d - r * r);\n          d = a.x;\n          h = f.x;\n          a = a.y;\n          var k = f.y;\n          f = d + r * (h - d) / b;\n          r = a + r * (k - a) / b;\n          a = p / b * -(k - a);\n          b = p / b * -(h - d);\n          h = [{\n            x: l(f + a, 14),\n            y: l(r - b, 14)\n          }, {\n            x: l(f - a, 14),\n            y: l(r + b, 14)\n          }];\n        }\n        return h;\n      }\n      function m(a) {\n        return a.reduce(function (a, b, d, p) {\n          p = p.slice(d + 1).reduce(function (a, f, p, h) {\n            var l = [d, p + d + 1];\n            return a.concat(k(b, f).map(function (a) {\n              a.indexes = l;\n              return a;\n            }));\n          }, []);\n          return a.concat(p);\n        }, []);\n      }\n      function w(a, f) {\n        return A(a, f) <= f.r + 1e-10;\n      }\n      function y(a, f) {\n        return !f.some(function (f) {\n          return !w(a, f);\n        });\n      }\n      function n(a) {\n        return m(a).filter(function (f) {\n          return y(f, a);\n        });\n      }\n      a.round = l;\n      a.getAreaOfCircle = q;\n      a.getCircularSegmentArea = h;\n      a.getOverlapBetweenCircles = function (a, f, b) {\n        var d = 0;\n        b < a + f && (b <= Math.abs(f - a) ? d = q(a < f ? a : f) : (d = (a * a - f * f + b * b) / (2 * b), b -= d, d = h(a, a - d) + h(f, f - b)), d = l(d, 14));\n        return d;\n      };\n      a.getCircleCircleIntersection = k;\n      a.getCirclesIntersectionPoints = m;\n      a.isCircle1CompletelyOverlappingCircle2 = function (a, b) {\n        return A(a, b) + b.r < a.r + 1e-10;\n      };\n      a.isPointInsideCircle = w;\n      a.isPointInsideAllCircles = y;\n      a.isPointOutsideAllCircles = function (a, b) {\n        return !b.some(function (b) {\n          return w(a, b);\n        });\n      };\n      a.getCirclesIntersectionPolygon = n;\n      a.getAreaOfIntersectionBetweenCircles = function (a) {\n        var f = n(a);\n        if (1 < f.length) {\n          var h = b(f);\n          f = f.map(function (a) {\n            a.angle = d(h, a);\n            return a;\n          }).sort(function (a, b) {\n            return b.angle - a.angle;\n          });\n          var l = f[f.length - 1];\n          f = f.reduce(function (f, h) {\n            var l = f.startPoint,\n              k = b([l, h]),\n              m = h.indexes.filter(function (a) {\n                return -1 < l.indexes.indexOf(a);\n              }).reduce(function (u, g) {\n                g = a[g];\n                var c = d(g, h),\n                  e = d(g, l);\n                c = e - (e - c + (e < c ? 2 * Math.PI : 0)) / 2;\n                c = A(k, {\n                  x: g.x + g.r * Math.sin(c),\n                  y: g.y + g.r * Math.cos(c)\n                });\n                g = g.r;\n                c > 2 * g && (c = 2 * g);\n                if (!u || u.width > c) u = {\n                  r: g,\n                  largeArc: c > g ? 1 : 0,\n                  width: c,\n                  x: h.x,\n                  y: h.y\n                };\n                return u;\n              }, null);\n            if (m) {\n              var t = m.r;\n              f.arcs.push([\"A\", t, t, 0, m.largeArc, 1, m.x, m.y]);\n              f.startPoint = h;\n            }\n            return f;\n          }, {\n            startPoint: l,\n            arcs: []\n          }).arcs;\n          if (0 !== f.length && 1 !== f.length) {\n            f.unshift([\"M\", l.x, l.y]);\n            var k = {\n              center: h,\n              d: f\n            };\n          }\n        }\n        return k;\n      };\n    })(m || (m = {}));\n    return m;\n  });\n  n(a, \"Series/DrawPointUtilities.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    return {\n      draw: function (a, b) {\n        var d = b.animatableAttribs,\n          m = b.onComplete,\n          w = b.css,\n          l = b.renderer,\n          q = a.series && a.series.chart.hasRendered ? void 0 : a.series && a.series.options.animation,\n          h = a.graphic;\n        b.attribs = b.attribs || {};\n        b.attribs[\"class\"] = a.getClassName();\n        if (a.shouldDraw()) h || (a.graphic = h = \"text\" === b.shapeType ? l.text() : l[b.shapeType](b.shapeArgs || {}), h.add(b.group)), w && h.css(w), h.attr(b.attribs).animate(d, b.isNew ? !1 : q, m);else if (h) {\n          var k = function () {\n            a.graphic = h = h && h.destroy();\n            \"function\" === typeof m && m();\n          };\n          Object.keys(d).length ? h.animate(d, void 0, function () {\n            return k();\n          }) : k();\n        }\n      }\n    };\n  });\n  n(a, \"Series/Venn/VennPoint.js\", [a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, d) {\n    var b = this && this.__extends || function () {\n        var a = function (b, d) {\n          a = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (a, b) {\n            a.__proto__ = b;\n          } || function (a, b) {\n            for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]);\n          };\n          return a(b, d);\n        };\n        return function (b, d) {\n          function l() {\n            this.constructor = b;\n          }\n          a(b, d);\n          b.prototype = null === d ? Object.create(d) : (l.prototype = d.prototype, new l());\n        };\n      }(),\n      y = d.isNumber;\n    return function (a) {\n      function d() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.options = void 0;\n        b.series = void 0;\n        return b;\n      }\n      b(d, a);\n      d.prototype.isValid = function () {\n        return y(this.value);\n      };\n      d.prototype.shouldDraw = function () {\n        return !!this.shapeArgs;\n      };\n      return d;\n    }(a.seriesTypes.scatter.prototype.pointClass);\n  });\n  n(a, \"Series/Venn/VennUtils.js\", [a[\"Core/Geometry/CircleUtilities.js\"], a[\"Core/Geometry/GeometryUtilities.js\"], a[\"Core/Utilities.js\"]], function (a, d, b) {\n    function n(a) {\n      var b = a.filter(function (a) {\n        return 2 === a.sets.length;\n      }).reduce(function (a, c) {\n        c.sets.forEach(function (e, b, g) {\n          z(a[e]) || (a[e] = {\n            overlapping: {},\n            totalOverlap: 0\n          });\n          a[e].totalOverlap += c.value;\n          a[e].overlapping[g[1 - b]] = c.value;\n        });\n        return a;\n      }, {});\n      a.filter(h).forEach(function (a) {\n        E(a, b[a.sets[0]]);\n      });\n      return a;\n    }\n    function m(a, b, g, c, e) {\n      var C = a(b),\n        u = a(g);\n      e = e || 100;\n      c = c || 1e-10;\n      var x = g - b,\n        d = 1;\n      if (b >= g) throw Error(\"a must be smaller than b.\");\n      if (0 < C * u) throw Error(\"f(a) and f(b) must have opposite signs.\");\n      if (0 === C) var t = b;else if (0 === u) t = g;else for (; d++ <= e && 0 !== f && x > c;) {\n        x = (g - b) / 2;\n        t = b + x;\n        var f = a(t);\n        0 < C * f ? b = t : g = t;\n      }\n      return t;\n    }\n    function w(a) {\n      a = a.slice(0, -1);\n      for (var b = a.length, g = [], c = function (a, c) {\n          a.sum += c[a.i];\n          return a;\n        }, e = 0; e < b; e++) g[e] = a.reduce(c, {\n        sum: 0,\n        i: e\n      }).sum / b;\n      return g;\n    }\n    function l(a, b, g) {\n      var c = a + b;\n      return 0 >= g ? c : J(a < b ? a : b) <= g ? 0 : m(function (c) {\n        c = p(a, b, c);\n        return g - c;\n      }, 0, c);\n    }\n    function q(a) {\n      var b = 0;\n      2 === a.length && (b = a[0], a = a[1], b = p(b.r, a.r, D(b, a)));\n      return b;\n    }\n    function h(a) {\n      return r(a.sets) && 1 === a.sets.length;\n    }\n    function k(a) {\n      var b = {};\n      return z(a) && F(a.value) && -1 < a.value && r(a.sets) && 0 < a.sets.length && !a.sets.some(function (a) {\n        var c = !1;\n        !b[a] && I(a) ? b[a] = !0 : c = !0;\n        return c;\n      });\n    }\n    function y(a, b) {\n      return b.reduce(function (b, c) {\n        var e = 0;\n        1 < c.sets.length && (e = c.value, c = q(c.sets.map(function (c) {\n          return a[c];\n        })), c = e - c, e = Math.round(c * c * 1E11) / 1E11);\n        return b + e;\n      }, 0);\n    }\n    function L(a, b) {\n      return b.totalOverlap - a.totalOverlap;\n    }\n    var J = a.getAreaOfCircle,\n      K = a.getCircleCircleIntersection,\n      p = a.getOverlapBetweenCircles,\n      f = a.isPointInsideAllCircles,\n      G = a.isPointInsideCircle,\n      H = a.isPointOutsideAllCircles,\n      D = d.getDistanceBetweenPoints,\n      E = b.extend,\n      r = b.isArray,\n      F = b.isNumber,\n      z = b.isObject,\n      I = b.isString;\n    return {\n      geometry: d,\n      geometryCircles: a,\n      addOverlapToSets: n,\n      getCentroid: w,\n      getDistanceBetweenCirclesByOverlap: l,\n      getLabelWidth: function (a, b, g) {\n        var c = b.reduce(function (a, c) {\n            return Math.min(c.r, a);\n          }, Infinity),\n          e = g.filter(function (c) {\n            return !G(a, c);\n          });\n        g = function (c, g) {\n          return m(function (x) {\n            var d = {\n              x: a.x + g * x,\n              y: a.y\n            };\n            d = f(d, b) && H(d, e);\n            return -(c - x) + (d ? 0 : Number.MAX_VALUE);\n          }, 0, c);\n        };\n        return 2 * Math.min(g(c, -1), g(c, 1));\n      },\n      getMarginFromCircles: function (a, b, g) {\n        b = b.reduce(function (c, b) {\n          b = b.r - D(a, b);\n          return b <= c ? b : c;\n        }, Number.MAX_VALUE);\n        return b = g.reduce(function (c, b) {\n          b = D(a, b) - b.r;\n          return b <= c ? b : c;\n        }, b);\n      },\n      isSet: h,\n      layoutGreedyVenn: function (a) {\n        var b = [],\n          g = {};\n        a.filter(function (a) {\n          return 1 === a.sets.length;\n        }).forEach(function (a) {\n          g[a.sets[0]] = a.circle = {\n            x: Number.MAX_VALUE,\n            y: Number.MAX_VALUE,\n            r: Math.sqrt(a.value / Math.PI)\n          };\n        });\n        var c = function (a, c) {\n          var e = a.circle;\n          e.x = c.x;\n          e.y = c.y;\n          b.push(a);\n        };\n        n(a);\n        var e = a.filter(h).sort(L);\n        c(e.shift(), {\n          x: 0,\n          y: 0\n        });\n        var d = a.filter(function (a) {\n          return 2 === a.sets.length;\n        });\n        e.forEach(function (a) {\n          var e = a.circle,\n            f = e.r,\n            C = a.overlapping,\n            v = b.reduce(function (a, c, x) {\n              var v = c.circle,\n                u = l(f, v.r, C[c.sets[0]]),\n                h = [{\n                  x: v.x + u,\n                  y: v.y\n                }, {\n                  x: v.x - u,\n                  y: v.y\n                }, {\n                  x: v.x,\n                  y: v.y + u\n                }, {\n                  x: v.x,\n                  y: v.y - u\n                }];\n              b.slice(x + 1).forEach(function (a) {\n                var c = a.circle;\n                a = l(f, c.r, C[a.sets[0]]);\n                h = h.concat(K({\n                  x: v.x,\n                  y: v.y,\n                  r: u\n                }, {\n                  x: c.x,\n                  y: c.y,\n                  r: a\n                }));\n              });\n              h.forEach(function (c) {\n                e.x = c.x;\n                e.y = c.y;\n                var b = y(g, d);\n                b < a.loss && (a.loss = b, a.coordinates = c);\n              });\n              return a;\n            }, {\n              loss: Number.MAX_VALUE,\n              coordinates: void 0\n            });\n          c(a, v.coordinates);\n        });\n        return g;\n      },\n      loss: y,\n      nelderMead: function (a, b) {\n        var g = function (a, c) {\n            return a.fx - c.fx;\n          },\n          c = function (a, c, b, e) {\n            return c.map(function (c, g) {\n              return a * c + b * e[g];\n            });\n          },\n          e = function (c, b) {\n            b.fx = a(b);\n            c[c.length - 1] = b;\n            return c;\n          },\n          d = function (b) {\n            var e = b[0];\n            return b.map(function (b) {\n              b = c(.5, e, .5, b);\n              b.fx = a(b);\n              return b;\n            });\n          },\n          f = function (b, e, g, d) {\n            b = c(g, b, d, e);\n            b.fx = a(b);\n            return b;\n          };\n        b = function (b) {\n          var c = b.length,\n            e = Array(c + 1);\n          e[0] = b;\n          e[0].fx = a(b);\n          for (var g = 0; g < c; ++g) {\n            var d = b.slice();\n            d[g] = d[g] ? 1.05 * d[g] : .001;\n            d.fx = a(d);\n            e[g + 1] = d;\n          }\n          return e;\n        }(b);\n        for (var x = 0; 100 > x; x++) {\n          b.sort(g);\n          var h = b[b.length - 1],\n            l = w(b),\n            B = f(l, h, 2, -1);\n          if (B.fx < b[0].fx) h = f(l, h, 3, -2), b = e(b, h.fx < B.fx ? h : B);else if (B.fx >= b[b.length - 2].fx) {\n            var k = void 0;\n            B.fx > h.fx ? (k = f(l, h, .5, .5), b = k.fx < h.fx ? e(b, k) : d(b)) : (k = f(l, h, 1.5, -.5), b = k.fx < B.fx ? e(b, k) : d(b));\n          } else b = e(b, B);\n        }\n        return b[0];\n      },\n      processVennData: function (a) {\n        a = r(a) ? a : [];\n        var b = a.reduce(function (a, b) {\n            k(b) && h(b) && 0 < b.value && -1 === a.indexOf(b.sets[0]) && a.push(b.sets[0]);\n            return a;\n          }, []).sort(),\n          g = a.reduce(function (a, e) {\n            k(e) && !e.sets.some(function (a) {\n              return -1 === b.indexOf(a);\n            }) && (a[e.sets.sort().join()] = e);\n            return a;\n          }, {});\n        b.reduce(function (a, b, g, d) {\n          d.slice(g + 1).forEach(function (c) {\n            a.push(b + \",\" + c);\n          });\n          return a;\n        }, []).forEach(function (a) {\n          if (!g[a]) {\n            var b = {\n              sets: a.split(\",\"),\n              value: 0\n            };\n            g[a] = b;\n          }\n        });\n        return Object.keys(g).map(function (a) {\n          return g[a];\n        });\n      },\n      sortByTotalOverlap: L\n    };\n  });\n  n(a, \"Series/Venn/VennSeries.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Geometry/CircleUtilities.js\"], a[\"Series/DrawPointUtilities.js\"], a[\"Core/Geometry/GeometryUtilities.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Series/Venn/VennPoint.js\"], a[\"Series/Venn/VennUtils.js\"], a[\"Core/Legend/LegendSymbol.js\"], a[\"Core/Utilities.js\"]], function (a, d, b, n, m, w, l, q, h, k) {\n    var y = this && this.__extends || function () {\n        var a = function (b, c) {\n          a = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (a, b) {\n            a.__proto__ = b;\n          } || function (a, b) {\n            for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n          };\n          return a(b, c);\n        };\n        return function (b, c) {\n          function e() {\n            this.constructor = b;\n          }\n          a(b, c);\n          b.prototype = null === c ? Object.create(c) : (e.prototype = c.prototype, new e());\n        };\n      }(),\n      A = a.animObject,\n      J = d.parse,\n      K = b.getAreaOfIntersectionBetweenCircles,\n      p = b.getCirclesIntersectionPolygon,\n      f = b.isCircle1CompletelyOverlappingCircle2,\n      G = b.isPointInsideAllCircles,\n      H = b.isPointOutsideAllCircles,\n      D = m.getCenterOfPoints,\n      E = w.seriesTypes.scatter;\n    a = k.addEvent;\n    var r = k.extend,\n      F = k.isArray,\n      z = k.isNumber,\n      I = k.isObject,\n      t = k.merge;\n    k = function (a) {\n      function b() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.data = void 0;\n        b.mapOfIdToRelation = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n      y(b, a);\n      b.getLabelPosition = function (a, b) {\n        var c = a.reduce(function (c, e) {\n          var d = e.r / 2;\n          return [{\n            x: e.x,\n            y: e.y\n          }, {\n            x: e.x + d,\n            y: e.y\n          }, {\n            x: e.x - d,\n            y: e.y\n          }, {\n            x: e.x,\n            y: e.y + d\n          }, {\n            x: e.x,\n            y: e.y - d\n          }].reduce(function (c, e) {\n            var d = q.getMarginFromCircles(e, a, b);\n            c.margin < d && (c.point = e, c.margin = d);\n            return c;\n          }, c);\n        }, {\n          point: void 0,\n          margin: -Number.MAX_VALUE\n        }).point;\n        c = q.nelderMead(function (c) {\n          return -q.getMarginFromCircles({\n            x: c[0],\n            y: c[1]\n          }, a, b);\n        }, [c.x, c.y]);\n        c = {\n          x: c[0],\n          y: c[1]\n        };\n        G(c, a) && H(c, b) || (c = 1 < a.length ? D(p(a)) : {\n          x: a[0].x,\n          y: a[0].y\n        });\n        return c;\n      };\n      b.getLabelValues = function (a, e) {\n        var c = a.sets,\n          d = e.reduce(function (a, b) {\n            var e = -1 < c.indexOf(b.sets[0]);\n            a[e ? \"internal\" : \"external\"].push(b.circle);\n            return a;\n          }, {\n            internal: [],\n            external: []\n          });\n        d.external = d.external.filter(function (a) {\n          return d.internal.some(function (b) {\n            return !f(a, b);\n          });\n        });\n        a = b.getLabelPosition(d.internal, d.external);\n        e = q.getLabelWidth(a, d.internal, d.external);\n        return {\n          position: a,\n          width: e\n        };\n      };\n      b.layout = function (a) {\n        var c = {},\n          d = {};\n        if (0 < a.length) {\n          var f = q.layoutGreedyVenn(a),\n            g = a.filter(q.isSet);\n          a.forEach(function (a) {\n            var e = a.sets,\n              h = e.join();\n            if (e = q.isSet(a) ? f[h] : K(e.map(function (a) {\n              return f[a];\n            }))) c[h] = e, d[h] = b.getLabelValues(a, g);\n          });\n        }\n        return {\n          mapOfIdToShape: c,\n          mapOfIdToLabelValues: d\n        };\n      };\n      b.getScale = function (a, b, d) {\n        var c = d.bottom - d.top,\n          e = d.right - d.left;\n        c = Math.min(0 < e ? 1 / e * a : 1, 0 < c ? 1 / c * b : 1);\n        return {\n          scale: c,\n          centerX: a / 2 - (d.right + d.left) / 2 * c,\n          centerY: b / 2 - (d.top + d.bottom) / 2 * c\n        };\n      };\n      b.updateFieldBoundaries = function (a, b) {\n        var c = b.x - b.r,\n          d = b.x + b.r,\n          e = b.y + b.r;\n        b = b.y - b.r;\n        if (!z(a.left) || a.left > c) a.left = c;\n        if (!z(a.right) || a.right < d) a.right = d;\n        if (!z(a.top) || a.top > b) a.top = b;\n        if (!z(a.bottom) || a.bottom < e) a.bottom = e;\n        return a;\n      };\n      b.prototype.animate = function (a) {\n        if (!a) {\n          var b = A(this.options.animation);\n          this.points.forEach(function (a) {\n            var c = a.shapeArgs;\n            if (a.graphic && c) {\n              var d = {},\n                e = {};\n              c.d ? d.opacity = .001 : (d.r = 0, e.r = c.r);\n              a.graphic.attr(d).animate(e, b);\n              c.d && setTimeout(function () {\n                a && a.graphic && a.graphic.animate({\n                  opacity: 1\n                });\n              }, b.duration);\n            }\n          }, this);\n        }\n      };\n      b.prototype.drawPoints = function () {\n        var a = this,\n          b = a.chart,\n          d = a.group,\n          f = b.renderer;\n        (a.points || []).forEach(function (c) {\n          var e = {\n              zIndex: F(c.sets) ? c.sets.length : 0\n            },\n            g = c.shapeArgs;\n          b.styledMode || r(e, a.pointAttribs(c, c.state));\n          n.draw(c, {\n            isNew: !c.graphic,\n            animatableAttribs: g,\n            attribs: e,\n            group: d,\n            renderer: f,\n            shapeType: g && g.d ? \"path\" : \"circle\"\n          });\n        });\n      };\n      b.prototype.init = function () {\n        E.prototype.init.apply(this, arguments);\n        delete this.opacity;\n      };\n      b.prototype.pointAttribs = function (a, b) {\n        var c = this.options || {};\n        a = t(c, {\n          color: a && a.color\n        }, a && a.options || {}, b && c.states[b] || {});\n        return {\n          fill: J(a.color).brighten(a.brightness).get(),\n          opacity: a.opacity,\n          stroke: a.borderColor,\n          \"stroke-width\": a.borderWidth,\n          dashstyle: a.borderDashStyle\n        };\n      };\n      b.prototype.translate = function () {\n        var a = this.chart;\n        this.processedXData = this.xData;\n        this.generatePoints();\n        var d = q.processVennData(this.options.data);\n        d = b.layout(d);\n        var f = d.mapOfIdToShape,\n          g = d.mapOfIdToLabelValues;\n        d = Object.keys(f).filter(function (a) {\n          return (a = f[a]) && z(a.r);\n        }).reduce(function (a, c) {\n          return b.updateFieldBoundaries(a, f[c]);\n        }, {\n          top: 0,\n          bottom: 0,\n          left: 0,\n          right: 0\n        });\n        a = b.getScale(a.plotWidth, a.plotHeight, d);\n        var h = a.scale,\n          k = a.centerX,\n          l = a.centerY;\n        this.points.forEach(function (a) {\n          var b = F(a.sets) ? a.sets : [],\n            c = b.join(),\n            d = f[c],\n            e = g[c] || {};\n          c = e.width;\n          e = e.position;\n          var m = a.options && a.options.dataLabels;\n          if (d) {\n            if (d.r) var n = {\n              x: k + d.x * h,\n              y: l + d.y * h,\n              r: d.r * h\n            };else d.d && (d = d.d, d.forEach(function (a) {\n              \"M\" === a[0] ? (a[1] = k + a[1] * h, a[2] = l + a[2] * h) : \"A\" === a[0] && (a[1] *= h, a[2] *= h, a[6] = k + a[6] * h, a[7] = l + a[7] * h);\n            }), n = {\n              d: d\n            });\n            e ? (e.x = k + e.x * h, e.y = l + e.y * h) : e = {};\n            z(c) && (c = Math.round(c * h));\n          }\n          a.shapeArgs = n;\n          e && n && (a.plotX = e.x, a.plotY = e.y);\n          c && n && (a.dlOptions = t(!0, {\n            style: {\n              width: c\n            }\n          }, I(m, !0) ? m : void 0));\n          a.name = a.options.name || b.join(\"\\u2229\");\n        });\n      };\n      b.defaultOptions = t(E.defaultOptions, {\n        borderColor: \"#cccccc\",\n        borderDashStyle: \"solid\",\n        borderWidth: 1,\n        brighten: 0,\n        clip: !1,\n        colorByPoint: !0,\n        dataLabels: {\n          enabled: !0,\n          verticalAlign: \"middle\",\n          formatter: function () {\n            return this.point.name;\n          }\n        },\n        inactiveOtherPoints: !0,\n        marker: !1,\n        opacity: .75,\n        showInLegend: !1,\n        legendType: \"point\",\n        states: {\n          hover: {\n            opacity: 1,\n            borderColor: \"#333333\"\n          },\n          select: {\n            color: \"#cccccc\",\n            borderColor: \"#000000\",\n            animation: !1\n          },\n          inactive: {\n            opacity: .075\n          }\n        },\n        tooltip: {\n          pointFormat: \"{point.name}: {point.value}\"\n        }\n      });\n      return b;\n    }(E);\n    r(k.prototype, {\n      axisTypes: [],\n      directTouch: !0,\n      drawLegendSymbol: h.drawRectangle,\n      isCartesian: !1,\n      pointArrayMap: [\"value\"],\n      pointClass: l,\n      utils: q\n    });\n    w.registerSeriesType(\"venn\", k);\n    \"\";\n    a(k, \"afterSetOptions\", function (a) {\n      var b = a.options.states;\n      this.is(\"venn\") && Object.keys(b).forEach(function (a) {\n        b[a].halo = !1;\n      });\n    });\n    return k;\n  });\n  n(a, \"masters/modules/venn.src.js\", [], function () {});\n});","map":{"version":3,"mappings":"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","names":["factory","module","define","Highcharts","undefined","_registerModule","obj","path","args","fn","CustomEvent","window","detail","_modules","GeometryUtilities","getCenterOfPoints","points","sum","point","x","y","getDistanceBetweenPoints","p1","p2","Math","getAngleBetweenPoints","Geometry","CircleUtilities","round","decimals","a","getAreaOfCircle","r","Error","getCircularSegmentArea","h","getCircleCircleIntersection","c1","c2","d","r1","r2","r1Square","x1","x2","y1","y2","x0","y0","rx","ry","getCirclesIntersectionPoints","circles","i","arr","additional","j","indexes","p","isPointInsideCircle","circle","isPointInsideAllCircles","getCirclesIntersectionPolygon","getOverlapBetweenCircles","overlap","d1","d2","isCircle1CompletelyOverlappingCircle2","circle1","circle2","isPointOutsideAllCircles","getAreaOfIntersectionBetweenCircles","intersectionPoints","center_1","b","startPoint","arcs","data","midPoint","arc","index","angle1","angle2","angle","width","largeArc","center","result","U","DrawPointUtilities","draw","params","animatableAttribs","onComplete","css","renderer","animation","graphic","destroy_1","Object","SeriesRegistry","__extends","extendStatics","__proto__","Array","__","isNumber","_super","VennPoint","_this","arguments","VennPoint.prototype.isValid","VennPoint.prototype.shouldDraw","CU","GU","addOverlapToSets","relations","mapOfIdToProps","relation","map","set","isObject","overlapping","totalOverlap","isSet","extend","properties","bisect","f","tolerance","maxIterations","fA","fB","nMax","tol","delta","n","fX","getCentroid","simplex","length","getDistanceBetweenCirclesByOverlap","maxDistance","distance","actualOverlap","getOverlapBetweenCirclesByDistance","isArray","isValidRelation","invalid","isString","loss","mapOfIdToCircle","totalLoss","wantedOverlap","diff","precision","sortByTotalOverlap","VennUtils","geometry","geometryCircles","getLabelWidth","pos","internal","external","radius","min","Infinity","filteredExternals","findDistance","direction","testPos","isValid","Number","getMarginFromCircles","margin","m","layoutGreedyVenn","positionedSets","mapOfIdToCircles","positionSet","coordinates","sortedByOverlap","relationsWithTwoSets","bestPosition","best","positionedSet","positionedCircle","possibleCoordinates","positionedSet2","positionedCircle2","distance2","overlap2","currentLoss","nelderMead","initial","sortByFx","weightedSum","weight1","v1","weight2","v2","updateSimplex","shrinkSimplex","pShrink","getPoint","centroid","worst","getSimplex","reflected","expanded","contracted","pOCon","processVennData","validSets","value","mapOfIdToRelation","combinations","remaining","forEach","set2","combination","sets","id","A","Color","DPU","LegendSymbol","animObject","color","ScatterSeries","addEvent","merge","VennSeries","VennSeries.getLabelPosition","optimal","VennSeries.getLabelValues","setRelations","isInternal","property","externalCircle","internalCircle","position","VennSeries.layout","mapOfIdToShape","mapOfIdToLabelValues","mapOfIdToCircles_1","setRelations_1","shape","VennSeries.getScale","targetWidth","targetHeight","field","height","scale","scaleX","scaleY","centerX","centerY","VennSeries.updateFieldBoundaries","left","right","bottom","top","VennSeries.prototype.animate","init","animOptions_1","series","options","attr","animate","setTimeout","opacity","VennSeries.prototype.drawPoints","chart","group","attribs","zIndex","shapeArgs","isNew","shapeType","VennSeries.prototype.init","prototype","VennSeries.prototype.pointAttribs","state","seriesOptions","fill","stroke","dashstyle","VennSeries.prototype.translate","_a","key","scaling","dataLabelValues","dataLabelWidth","dataLabelPosition","dlOptions","seg","style","borderColor","borderDashStyle","borderWidth","brighten","clip","colorByPoint","dataLabels","enabled","verticalAlign","formatter","inactiveOtherPoints","marker","showInLegend","legendType","states","hover","select","inactive","tooltip","pointFormat","axisTypes","directTouch","drawLegendSymbol","isCartesian","pointArrayMap","pointClass","utils","e"],"sources":["/Users/borislav26/GolandProjects/planted/frontend/node_modules/highcharts/modules/venn.src.js"],"sourcesContent":["/**\n * @license Highcharts JS v10.3.1 (2022-10-31)\n *\n * (c) 2017-2021 Highsoft AS\n * Authors: Jon Arild Nygard\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/venn', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(\n                    new CustomEvent(\n                        'HighchartsModuleLoaded',\n                        { detail: { path: path, module: obj[path] }\n                    })\n                );\n            }\n        }\n    }\n    _registerModule(_modules, 'Core/Geometry/GeometryUtilities.js', [], function () {\n        /* *\n         *\n         *  (c) 2010-2021 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Namespace\n         *\n         * */\n        var GeometryUtilities;\n        (function (GeometryUtilities) {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Calculates the center between a list of points.\n             *\n             * @private\n             *\n             * @param {Array<Highcharts.PositionObject>} points\n             * A list of points to calculate the center of.\n             *\n             * @return {Highcharts.PositionObject}\n             * Calculated center\n             */\n            function getCenterOfPoints(points) {\n                var sum = points.reduce(function (sum,\n                    point) {\n                        sum.x += point.x;\n                    sum.y += point.y;\n                    return sum;\n                }, { x: 0, y: 0 });\n                return {\n                    x: sum.x / points.length,\n                    y: sum.y / points.length\n                };\n            }\n            GeometryUtilities.getCenterOfPoints = getCenterOfPoints;\n            /**\n             * Calculates the distance between two points based on their x and y\n             * coordinates.\n             *\n             * @private\n             *\n             * @param {Highcharts.PositionObject} p1\n             * The x and y coordinates of the first point.\n             *\n             * @param {Highcharts.PositionObject} p2\n             * The x and y coordinates of the second point.\n             *\n             * @return {number}\n             * Returns the distance between the points.\n             */\n            function getDistanceBetweenPoints(p1, p2) {\n                return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n            }\n            GeometryUtilities.getDistanceBetweenPoints = getDistanceBetweenPoints;\n            /**\n             * Calculates the angle between two points.\n             * @todo add unit tests.\n             * @private\n             * @param {Highcharts.PositionObject} p1 The first point.\n             * @param {Highcharts.PositionObject} p2 The second point.\n             * @return {number} Returns the angle in radians.\n             */\n            function getAngleBetweenPoints(p1, p2) {\n                return Math.atan2(p2.x - p1.x, p2.y - p1.y);\n            }\n            GeometryUtilities.getAngleBetweenPoints = getAngleBetweenPoints;\n        })(GeometryUtilities || (GeometryUtilities = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return GeometryUtilities;\n    });\n    _registerModule(_modules, 'Core/Geometry/CircleUtilities.js', [_modules['Core/Geometry/GeometryUtilities.js']], function (Geometry) {\n        /* *\n         *\n         *  (c) 2010-2021 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var getAngleBetweenPoints = Geometry.getAngleBetweenPoints,\n            getCenterOfPoints = Geometry.getCenterOfPoints,\n            getDistanceBetweenPoints = Geometry.getDistanceBetweenPoints;\n        /* *\n         *\n         *  Namespace\n         *\n         * */\n        var CircleUtilities;\n        (function (CircleUtilities) {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * @private\n             *\n             * @param {number} x\n             * Number to round\n             *\n             * @param {number} decimals\n             * Number of decimals to round to\n             *\n             * @return {number}\n             * Rounded number\n             */\n            function round(x, decimals) {\n                var a = Math.pow(10,\n                    decimals);\n                return Math.round(x * a) / a;\n            }\n            CircleUtilities.round = round;\n            /**\n             * Calculates the area of a circle based on its radius.\n             *\n             * @private\n             *\n             * @param {number} r\n             * The radius of the circle.\n             *\n             * @return {number}\n             * Returns the area of the circle.\n             */\n            function getAreaOfCircle(r) {\n                if (r <= 0) {\n                    throw new Error('radius of circle must be a positive number.');\n                }\n                return Math.PI * r * r;\n            }\n            CircleUtilities.getAreaOfCircle = getAreaOfCircle;\n            /**\n             * Calculates the area of a circular segment based on the radius of the\n             * circle and the height of the segment.\n             *\n             * @see http://mathworld.wolfram.com/CircularSegment.html\n             *\n             * @private\n             *\n             * @param {number} r\n             * The radius of the circle.\n             *\n             * @param {number} h\n             * The height of the circular segment.\n             *\n             * @return {number}\n             * Returns the area of the circular segment.\n             */\n            function getCircularSegmentArea(r, h) {\n                return (r * r * Math.acos(1 - h / r) -\n                    (r - h) * Math.sqrt(h * (2 * r - h)));\n            }\n            CircleUtilities.getCircularSegmentArea = getCircularSegmentArea;\n            /**\n             * Calculates the area of overlap between two circles based on their\n             * radiuses and the distance between them.\n             *\n             * @see http://mathworld.wolfram.com/Circle-CircleIntersection.html\n             *\n             * @private\n             *\n             * @param {number} r1\n             * Radius of the first circle.\n             *\n             * @param {number} r2\n             * Radius of the second circle.\n             *\n             * @param {number} d\n             * The distance between the two circles.\n             *\n             * @return {number}\n             * Returns the area of overlap between the two circles.\n             */\n            function getOverlapBetweenCircles(r1, r2, d) {\n                var overlap = 0;\n                // If the distance is larger than the sum of the radiuses then the\n                // circles does not overlap.\n                if (d < r1 + r2) {\n                    if (d <= Math.abs(r2 - r1)) {\n                        // If the circles are completely overlapping, then the overlap\n                        // equals the area of the smallest circle.\n                        overlap = getAreaOfCircle(r1 < r2 ? r1 : r2);\n                    }\n                    else {\n                        // Height of first triangle segment.\n                        var d1 = (r1 * r1 - r2 * r2 + d * d) / (2 * d), \n                            // Height of second triangle segment.\n                            d2 = d - d1;\n                        overlap = (getCircularSegmentArea(r1, r1 - d1) +\n                            getCircularSegmentArea(r2, r2 - d2));\n                    }\n                    // Round the result to two decimals.\n                    overlap = round(overlap, 14);\n                }\n                return overlap;\n            }\n            CircleUtilities.getOverlapBetweenCircles = getOverlapBetweenCircles;\n            /**\n             * Calculates the intersection points of two circles.\n             *\n             * NOTE: does not handle floating errors well.\n             *\n             * @private\n             *\n             * @param {Highcharts.CircleObject} c1\n             * The first circle.\n             *\n             * @param {Highcharts.CircleObject} c2\n             * The second sircle.\n             *\n             * @return {Array<Highcharts.PositionObject>}\n             * Returns the resulting intersection points.\n             */\n            function getCircleCircleIntersection(c1, c2) {\n                var d = getDistanceBetweenPoints(c1,\n                    c2),\n                    r1 = c1.r,\n                    r2 = c2.r;\n                var points = [];\n                if (d < r1 + r2 && d > Math.abs(r1 - r2)) {\n                    // If the circles are overlapping, but not completely overlapping,\n                    // then it exists intersecting points.\n                    var r1Square = r1 * r1,\n                        r2Square = r2 * r2, \n                        // d^2 - r^2 + R^2 / 2d\n                        x = (r1Square - r2Square + d * d) / (2 * d), \n                        // y^2 = R^2 - x^2\n                        y = Math.sqrt(r1Square - x * x),\n                        x1 = c1.x,\n                        x2 = c2.x,\n                        y1 = c1.y,\n                        y2 = c2.y,\n                        x0 = x1 + x * (x2 - x1) / d,\n                        y0 = y1 + x * (y2 - y1) / d,\n                        rx = -(y2 - y1) * (y / d),\n                        ry = -(x2 - x1) * (y / d);\n                    points = [\n                        { x: round(x0 + rx, 14), y: round(y0 - ry, 14) },\n                        { x: round(x0 - rx, 14), y: round(y0 + ry, 14) }\n                    ];\n                }\n                return points;\n            }\n            CircleUtilities.getCircleCircleIntersection = getCircleCircleIntersection;\n            /**\n             * Calculates all the intersection points for between a list of circles.\n             *\n             * @private\n             *\n             * @param {Array<Highcharts.CircleObject>} circles\n             * The circles to calculate the points from.\n             *\n             * @return {Array<Highcharts.GeometryObject>}\n             * Returns a list of intersection points.\n             */\n            function getCirclesIntersectionPoints(circles) {\n                return circles.reduce(function (points, c1, i, arr) {\n                    var additional = arr\n                            .slice(i + 1)\n                            .reduce(function (points,\n                        c2,\n                        j,\n                        arr) {\n                            var indexes = [i,\n                        j + i + 1];\n                        return points.concat(getCircleCircleIntersection(c1, c2).map(function (p) {\n                            p.indexes = indexes;\n                            return p;\n                        }));\n                    }, []);\n                    return points.concat(additional);\n                }, []);\n            }\n            CircleUtilities.getCirclesIntersectionPoints = getCirclesIntersectionPoints;\n            /**\n             * Tests whether the first circle is completely overlapping the second\n             * circle.\n             *\n             * @private\n             *\n             * @param {Highcharts.CircleObject} circle1\n             * The first circle.\n             *\n             * @param {Highcharts.CircleObject} circle2\n             * The The second circle.\n             *\n             * @return {boolean}\n             * Returns true if circle1 is completely overlapping circle2, false if not.\n             */\n            function isCircle1CompletelyOverlappingCircle2(circle1, circle2) {\n                return getDistanceBetweenPoints(circle1, circle2) + circle2.r < circle1.r + 1e-10;\n            }\n            CircleUtilities.isCircle1CompletelyOverlappingCircle2 = isCircle1CompletelyOverlappingCircle2;\n            /**\n             * Tests whether a point lies within a given circle.\n             * @private\n             * @param {Highcharts.PositionObject} point\n             * The point to test for.\n             *\n             * @param {Highcharts.CircleObject} circle\n             * The circle to test if the point is within.\n             *\n             * @return {boolean}\n             * Returns true if the point is inside, false if outside.\n             */\n            function isPointInsideCircle(point, circle) {\n                return getDistanceBetweenPoints(point, circle) <= circle.r + 1e-10;\n            }\n            CircleUtilities.isPointInsideCircle = isPointInsideCircle;\n            /**\n             * Tests whether a point lies within a set of circles.\n             *\n             * @private\n             *\n             * @param {Highcharts.PositionObject} point\n             * The point to test.\n             *\n             * @param {Array<Highcharts.CircleObject>} circles\n             * The list of circles to test against.\n             *\n             * @return {boolean}\n             * Returns true if the point is inside all the circles, false if not.\n             */\n            function isPointInsideAllCircles(point, circles) {\n                return !circles.some(function (circle) {\n                    return !isPointInsideCircle(point, circle);\n                });\n            }\n            CircleUtilities.isPointInsideAllCircles = isPointInsideAllCircles;\n            /**\n             * Tests whether a point lies outside a set of circles.\n             *\n             * TODO: add unit tests.\n             *\n             * @private\n             *\n             * @param {Highcharts.PositionObject} point\n             * The point to test.\n             *\n             * @param {Array<Highcharts.CircleObject>} circles\n             * The list of circles to test against.\n             *\n             * @return {boolean}\n             * Returns true if the point is outside all the circles, false if not.\n             */\n            function isPointOutsideAllCircles(point, circles) {\n                return !circles.some(function (circle) {\n                    return isPointInsideCircle(point, circle);\n                });\n            }\n            CircleUtilities.isPointOutsideAllCircles = isPointOutsideAllCircles;\n            /**\n             * Calculates the points for the polygon of the intersection area between\n             * a set of circles.\n             *\n             * @private\n             *\n             * @param {Array<Highcharts.CircleObject>} circles\n             * List of circles to calculate polygon of.\n             *\n             * @return {Array<Highcharts.GeometryObject>}\n             * Return list of points in the intersection polygon.\n             */\n            function getCirclesIntersectionPolygon(circles) {\n                return getCirclesIntersectionPoints(circles)\n                    .filter(function (p) {\n                    return isPointInsideAllCircles(p, circles);\n                });\n            }\n            CircleUtilities.getCirclesIntersectionPolygon = getCirclesIntersectionPolygon;\n            /**\n             * Calculate the path for the area of overlap between a set of circles.\n             *\n             * @todo handle cases with only 1 or 0 arcs.\n             *\n             * @private\n             *\n             * @param {Array<Highcharts.CircleObject>} circles\n             * List of circles to calculate area of.\n             *\n             * @return {Highcharts.GeometryIntersectionObject|undefined}\n             * Returns the path for the area of overlap. Returns an empty string if\n             * there are no intersection between all the circles.\n             */\n            function getAreaOfIntersectionBetweenCircles(circles) {\n                var intersectionPoints = getCirclesIntersectionPolygon(circles),\n                    result;\n                if (intersectionPoints.length > 1) {\n                    // Calculate the center of the intersection points.\n                    var center_1 = getCenterOfPoints(intersectionPoints);\n                    intersectionPoints = intersectionPoints\n                        // Calculate the angle between the center and the points.\n                        .map(function (p) {\n                        p.angle = getAngleBetweenPoints(center_1, p);\n                        return p;\n                    })\n                        // Sort the points by the angle to the center.\n                        .sort(function (a, b) {\n                        return b.angle - a.angle;\n                    });\n                    var startPoint = intersectionPoints[intersectionPoints.length - 1];\n                    var arcs = intersectionPoints\n                            .reduce(function (data,\n                        p1) {\n                            var startPoint = data.startPoint,\n                        midPoint = getCenterOfPoints([startPoint,\n                        p1]);\n                        // Calculate the arc from the intersection points and their\n                        // circles.\n                        var arc = p1.indexes\n                                // Filter out circles that are not included in both\n                                // intersection points.\n                                .filter(function (index) {\n                                return startPoint.indexes.indexOf(index) > -1;\n                        })\n                            // Iterate the circles of the intersection points and\n                            // calculate arcs.\n                            .reduce(function (arc, index) {\n                            var circle = circles[index],\n                                angle1 = getAngleBetweenPoints(circle,\n                                p1),\n                                angle2 = getAngleBetweenPoints(circle,\n                                startPoint),\n                                angleDiff = angle2 - angle1 +\n                                    (angle2 < angle1 ? 2 * Math.PI : 0),\n                                angle = angle2 - angleDiff / 2;\n                            var width = getDistanceBetweenPoints(midPoint, {\n                                    x: circle.x + circle.r * Math.sin(angle),\n                                    y: circle.y + circle.r * Math.cos(angle)\n                                });\n                            var r = circle.r;\n                            // Width can sometimes become to large due to\n                            // floating point errors\n                            if (width > r * 2) {\n                                width = r * 2;\n                            }\n                            // Get the arc with the smallest width.\n                            if (!arc || arc.width > width) {\n                                arc = {\n                                    r: r,\n                                    largeArc: width > r ? 1 : 0,\n                                    width: width,\n                                    x: p1.x,\n                                    y: p1.y\n                                };\n                            }\n                            // Return the chosen arc.\n                            return arc;\n                        }, null);\n                        // If we find an arc then add it to the list and update p2.\n                        if (arc) {\n                            var r = arc.r;\n                            data.arcs.push(['A', r, r, 0, arc.largeArc, 1, arc.x, arc.y]);\n                            data.startPoint = p1;\n                        }\n                        return data;\n                    }, {\n                        startPoint: startPoint,\n                        arcs: []\n                    }).arcs;\n                    if (arcs.length === 0) {\n                        // empty\n                    }\n                    else if (arcs.length === 1) {\n                        // empty\n                    }\n                    else {\n                        arcs.unshift(['M', startPoint.x, startPoint.y]);\n                        result = {\n                            center: center_1,\n                            d: arcs\n                        };\n                    }\n                }\n                return result;\n            }\n            CircleUtilities.getAreaOfIntersectionBetweenCircles = getAreaOfIntersectionBetweenCircles;\n        })(CircleUtilities || (CircleUtilities = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return CircleUtilities;\n    });\n    _registerModule(_modules, 'Series/DrawPointUtilities.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var isNumber = U.isNumber;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Handles the drawing of a component.\n         * Can be used for any type of component that reserves the graphic property,\n         * and provides a shouldDraw on its context.\n         *\n         * @private\n         *\n         * @todo add type checking.\n         * @todo export this function to enable usage\n         */\n        function draw(point, params) {\n            var animatableAttribs = params.animatableAttribs,\n                onComplete = params.onComplete,\n                css = params.css,\n                renderer = params.renderer;\n            var animation = (point.series && point.series.chart.hasRendered) ?\n                    // Chart-level animation on updates\n                    void 0 :\n                    // Series-level animation on new points\n                    (point.series &&\n                        point.series.options.animation);\n            var graphic = point.graphic;\n            params.attribs = params.attribs || {};\n            // Assigning class in dot notation does go well in IE8\n            // eslint-disable-next-line dot-notation\n            params.attribs['class'] = point.getClassName();\n            if ((point.shouldDraw())) {\n                if (!graphic) {\n                    point.graphic = graphic = params.shapeType === 'text' ?\n                        renderer.text() :\n                        renderer[params.shapeType](params.shapeArgs || {});\n                    graphic.add(params.group);\n                }\n                if (css) {\n                    graphic.css(css);\n                }\n                graphic\n                    .attr(params.attribs)\n                    .animate(animatableAttribs, params.isNew ? false : animation, onComplete);\n            }\n            else if (graphic) {\n                var destroy_1 = function () {\n                        point.graphic = graphic = (graphic && graphic.destroy());\n                    if (typeof onComplete === 'function') {\n                        onComplete();\n                    }\n                };\n                // animate only runs complete callback if something was animated.\n                if (Object.keys(animatableAttribs).length) {\n                    graphic.animate(animatableAttribs, void 0, function () { return destroy_1(); });\n                }\n                else {\n                    destroy_1();\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var DrawPointUtilities = {\n                draw: draw\n            };\n\n        return DrawPointUtilities;\n    });\n    _registerModule(_modules, 'Series/Venn/VennPoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (SeriesRegistry, U) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a Venn\n         *  diagram.\n         *\n         *  (c) 2016-2021 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  Layout algorithm by Ben Frederickson:\n         *  https://www.benfrederickson.com/better-venn-diagrams/\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var ScatterPoint = SeriesRegistry.seriesTypes.scatter.prototype.pointClass;\n        var extend = U.extend,\n            isNumber = U.isNumber;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        var VennPoint = /** @class */ (function (_super) {\n                __extends(VennPoint, _super);\n            function VennPoint() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                _this.options = void 0;\n                _this.series = void 0;\n                return _this;\n                /* eslint-enable valid-jsdoc */\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            VennPoint.prototype.isValid = function () {\n                return isNumber(this.value);\n            };\n            VennPoint.prototype.shouldDraw = function () {\n                // Only draw points with single sets.\n                return !!this.shapeArgs;\n            };\n            return VennPoint;\n        }(ScatterPoint));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return VennPoint;\n    });\n    _registerModule(_modules, 'Series/Venn/VennUtils.js', [_modules['Core/Geometry/CircleUtilities.js'], _modules['Core/Geometry/GeometryUtilities.js'], _modules['Core/Utilities.js']], function (CU, GU, U) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a Venn\n         *  diagram.\n         *\n         *  (c) 2016-2021 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  Layout algorithm by Ben Frederickson:\n         *  https://www.benfrederickson.com/better-venn-diagrams/\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var getAreaOfCircle = CU.getAreaOfCircle,\n            getCircleCircleIntersection = CU.getCircleCircleIntersection,\n            getOverlapBetweenCirclesByDistance = CU.getOverlapBetweenCircles,\n            isPointInsideAllCircles = CU.isPointInsideAllCircles,\n            isPointInsideCircle = CU.isPointInsideCircle,\n            isPointOutsideAllCircles = CU.isPointOutsideAllCircles;\n        var getDistanceBetweenPoints = GU.getDistanceBetweenPoints;\n        var extend = U.extend,\n            isArray = U.isArray,\n            isNumber = U.isNumber,\n            isObject = U.isObject,\n            isString = U.isString;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * Takes an array of relations and adds the properties `totalOverlap` and\n         * `overlapping` to each set. The property `totalOverlap` is the sum of\n         * value for each relation where this set is included. The property\n         * `overlapping` is a map of how much this set is overlapping another set.\n         * NOTE: This algorithm ignores relations consisting of more than 2 sets.\n         * @private\n         * @param {Array<Highcharts.VennRelationObject>} relations\n         * The list of relations that should be sorted.\n         * @return {Array<Highcharts.VennRelationObject>}\n         * Returns the modified input relations with added properties `totalOverlap`\n         * and `overlapping`.\n         */\n        function addOverlapToSets(relations) {\n            // Calculate the amount of overlap per set.\n            var mapOfIdToProps = relations\n                    // Filter out relations consisting of 2 sets.\n                    .filter(function (relation) { return (relation.sets.length === 2); })\n                    // Sum up the amount of overlap for each set.\n                    .reduce(function (map,\n                relation) {\n                    relation.sets.forEach(function (set,\n                i,\n                arr) {\n                        if (!isObject(map[set])) {\n                            map[set] = {\n                                overlapping: {},\n                                totalOverlap: 0\n                            };\n                    }\n                    map[set].totalOverlap += relation.value;\n                    map[set].overlapping[arr[1 - i]] = relation.value;\n                });\n                return map;\n            }, {});\n            relations\n                // Filter out single sets\n                .filter(isSet)\n                // Extend the set with the calculated properties.\n                .forEach(function (set) {\n                var properties = mapOfIdToProps[set.sets[0]];\n                extend(set, properties);\n            });\n            // Returns the modified relations.\n            return relations;\n        }\n        /**\n         * Finds the root of a given function. The root is the input value needed\n         * for a function to return 0.\n         *\n         * See https://en.wikipedia.org/wiki/Bisection_method#Algorithm\n         *\n         * TODO: Add unit tests.\n         *\n         * @param {Function} f\n         * The function to find the root of.\n         * @param {number} a\n         * The lowest number in the search range.\n         * @param {number} b\n         * The highest number in the search range.\n         * @param {number} [tolerance=1e-10]\n         * The allowed difference between the returned value and root.\n         * @param {number} [maxIterations=100]\n         * The maximum iterations allowed.\n         * @return {number}\n         * Root number.\n         */\n        function bisect(f, a, b, tolerance, maxIterations) {\n            var fA = f(a),\n                fB = f(b),\n                nMax = maxIterations || 100,\n                tol = tolerance || 1e-10,\n                delta = b - a,\n                n = 1,\n                x,\n                fX;\n            if (a >= b) {\n                throw new Error('a must be smaller than b.');\n            }\n            else if (fA * fB > 0) {\n                throw new Error('f(a) and f(b) must have opposite signs.');\n            }\n            if (fA === 0) {\n                x = a;\n            }\n            else if (fB === 0) {\n                x = b;\n            }\n            else {\n                while (n++ <= nMax && fX !== 0 && delta > tol) {\n                    delta = (b - a) / 2;\n                    x = a + delta;\n                    fX = f(x);\n                    // Update low and high for next search interval.\n                    if (fA * fX > 0) {\n                        a = x;\n                    }\n                    else {\n                        b = x;\n                    }\n                }\n            }\n            return x;\n        }\n        /**\n         * @private\n         */\n        function getCentroid(simplex) {\n            var arr = simplex.slice(0, -1),\n                length = arr.length,\n                result = [],\n                sum = function (data,\n                point) {\n                    data.sum += point[data.i];\n                return data;\n            };\n            for (var i = 0; i < length; i++) {\n                result[i] = arr.reduce(sum, { sum: 0, i: i }).sum / length;\n            }\n            return result;\n        }\n        /**\n         * Uses the bisection method to make a best guess of the ideal distance\n         * between two circles too get the desired overlap.\n         * Currently there is no known formula to calculate the distance from the\n         * area of overlap, which makes the bisection method preferred.\n         * @private\n         * @param {number} r1\n         * Radius of the first circle.\n         * @param {number} r2\n         * Radiues of the second circle.\n         * @param {number} overlap\n         * The wanted overlap between the two circles.\n         * @return {number}\n         * Returns the distance needed to get the wanted overlap between the two\n         * circles.\n         */\n        function getDistanceBetweenCirclesByOverlap(r1, r2, overlap) {\n            var maxDistance = r1 + r2,\n                distance;\n            if (overlap <= 0) {\n                // If overlap is below or equal to zero, then there is no overlap.\n                distance = maxDistance;\n            }\n            else if (getAreaOfCircle(r1 < r2 ? r1 : r2) <= overlap) {\n                // When area of overlap is larger than the area of the smallest\n                // circle, then it is completely overlapping.\n                distance = 0;\n            }\n            else {\n                distance = bisect(function (x) {\n                    var actualOverlap = getOverlapBetweenCirclesByDistance(r1,\n                        r2,\n                        x);\n                    // Return the differance between wanted and actual overlap.\n                    return overlap - actualOverlap;\n                }, 0, maxDistance);\n            }\n            return distance;\n        }\n        /**\n         * Finds the available width for a label, by taking the label position and\n         * finding the largest distance, which is inside all internal circles, and\n         * outside all external circles.\n         *\n         * @private\n         * @param {Highcharts.PositionObject} pos\n         * The x and y coordinate of the label.\n         * @param {Array<Highcharts.CircleObject>} internal\n         * Internal circles.\n         * @param {Array<Highcharts.CircleObject>} external\n         * External circles.\n         * @return {number}\n         * Returns available width for the label.\n         */\n        function getLabelWidth(pos, internal, external) {\n            var radius = internal.reduce(function (min,\n                circle) { return Math.min(circle.r,\n                min); },\n                Infinity), \n                // Filter out external circles that are completely overlapping.\n                filteredExternals = external.filter(function (circle) {\n                    return !isPointInsideCircle(pos,\n                circle);\n            });\n            var findDistance = function (maxDistance,\n                direction) {\n                    return bisect(function (x) {\n                        var testPos = {\n                            x: pos.x + (direction * x),\n                            y: pos.y\n                        },\n                isValid = (isPointInsideAllCircles(testPos,\n                internal) &&\n                            isPointOutsideAllCircles(testPos,\n                filteredExternals));\n                    // If the position is valid, then we want to move towards the\n                    // max distance. If not, then we want to  away from the max\n                    // distance.\n                    return -(maxDistance - x) + (isValid ? 0 : Number.MAX_VALUE);\n                }, 0, maxDistance);\n            };\n            // Find the smallest distance of left and right.\n            return Math.min(findDistance(radius, -1), findDistance(radius, 1)) * 2;\n        }\n        /**\n         * Calculates a margin for a point based on the iternal and external\n         * circles. The margin describes if the point is well placed within the\n         * internal circles, and away from the external.\n         * @private\n         * @todo add unit tests.\n         * @param {Highcharts.PositionObject} point\n         * The point to evaluate.\n         * @param {Array<Highcharts.CircleObject>} internal\n         * The internal circles.\n         * @param {Array<Highcharts.CircleObject>} external\n         * The external circles.\n         * @return {number}\n         * Returns the margin.\n         */\n        function getMarginFromCircles(point, internal, external) {\n            var margin = internal.reduce(function (margin,\n                circle) {\n                    var m = circle.r - getDistanceBetweenPoints(point,\n                circle);\n                return (m <= margin) ? m : margin;\n            }, Number.MAX_VALUE);\n            margin = external.reduce(function (margin, circle) {\n                var m = getDistanceBetweenPoints(point,\n                    circle) - circle.r;\n                return (m <= margin) ? m : margin;\n            }, margin);\n            return margin;\n        }\n        /**\n         * Calculates the area of overlap between a list of circles.\n         * @private\n         * @todo add support for calculating overlap between more than 2 circles.\n         * @param {Array<Highcharts.CircleObject>} circles\n         * List of circles with their given positions.\n         * @return {number}\n         * Returns the area of overlap between all the circles.\n         */\n        function getOverlapBetweenCircles(circles) {\n            var overlap = 0;\n            // When there is only two circles we can find the overlap by using their\n            // radiuses and the distance between them.\n            if (circles.length === 2) {\n                var circle1 = circles[0];\n                var circle2 = circles[1];\n                overlap = getOverlapBetweenCirclesByDistance(circle1.r, circle2.r, getDistanceBetweenPoints(circle1, circle2));\n            }\n            return overlap;\n        }\n        // eslint-disable-next-line require-jsdoc\n        function isSet(x) {\n            return isArray(x.sets) && x.sets.length === 1;\n        }\n        // eslint-disable-next-line require-jsdoc\n        function isValidRelation(x) {\n            var map = {};\n            return (isObject(x) &&\n                (isNumber(x.value) && x.value > -1) &&\n                (isArray(x.sets) && x.sets.length > 0) &&\n                !x.sets.some(function (set) {\n                    var invalid = false;\n                    if (!map[set] && isString(set)) {\n                        map[set] = true;\n                    }\n                    else {\n                        invalid = true;\n                    }\n                    return invalid;\n                }));\n        }\n        // eslint-disable-next-line require-jsdoc\n        function isValidSet(x) {\n            return (isValidRelation(x) && isSet(x) && x.value > 0);\n        }\n        /**\n         * Uses a greedy approach to position all the sets. Works well with a small\n         * number of sets, and are in these cases a good choice aesthetically.\n         * @private\n         * @param {Array<object>} relations List of the overlap between two or more\n         * sets, or the size of a single set.\n         * @return {Array<object>} List of circles and their calculated positions.\n         */\n        function layoutGreedyVenn(relations) {\n            var positionedSets = [],\n                mapOfIdToCircles = {};\n            // Define a circle for each set.\n            relations\n                .filter(function (relation) {\n                return relation.sets.length === 1;\n            }).forEach(function (relation) {\n                mapOfIdToCircles[relation.sets[0]] = relation.circle = {\n                    x: Number.MAX_VALUE,\n                    y: Number.MAX_VALUE,\n                    r: Math.sqrt(relation.value / Math.PI)\n                };\n            });\n            /**\n             * Takes a set and updates the position, and add the set to the list of\n             * positioned sets.\n             * @private\n             * @param {Object} set\n             * The set to add to its final position.\n             * @param {Object} coordinates\n             * The coordinates to position the set at.\n             */\n            var positionSet = function positionSet(set,\n                coordinates) {\n                    var circle = set.circle;\n                circle.x = coordinates.x;\n                circle.y = coordinates.y;\n                positionedSets.push(set);\n            };\n            // Find overlap between sets. Ignore relations with more then 2 sets.\n            addOverlapToSets(relations);\n            // Sort sets by the sum of their size from large to small.\n            var sortedByOverlap = relations\n                    .filter(isSet)\n                    .sort(sortByTotalOverlap);\n            // Position the most overlapped set at 0,0.\n            positionSet(sortedByOverlap.shift(), { x: 0, y: 0 });\n            var relationsWithTwoSets = relations.filter(function (x) {\n                    return x.sets.length === 2;\n            });\n            // Iterate and position the remaining sets.\n            sortedByOverlap.forEach(function (set) {\n                var circle = set.circle,\n                    radius = circle.r,\n                    overlapping = set.overlapping;\n                var bestPosition = positionedSets.reduce(function (best,\n                    positionedSet,\n                    i) {\n                        var positionedCircle = positionedSet.circle,\n                    overlap = overlapping[positionedSet.sets[0]];\n                    // Calculate the distance between the sets to get the\n                    // correct overlap\n                    var distance = getDistanceBetweenCirclesByOverlap(radius,\n                        positionedCircle.r,\n                        overlap);\n                    // Create a list of possible coordinates calculated from\n                    // distance.\n                    var possibleCoordinates = [\n                            { x: positionedCircle.x + distance,\n                        y: positionedCircle.y },\n                            { x: positionedCircle.x - distance,\n                        y: positionedCircle.y },\n                            { x: positionedCircle.x,\n                        y: positionedCircle.y + distance },\n                            { x: positionedCircle.x,\n                        y: positionedCircle.y - distance }\n                        ];\n                    // If there are more circles overlapping, then add the\n                    // intersection points as possible positions.\n                    positionedSets.slice(i + 1).forEach(function (positionedSet2) {\n                        var positionedCircle2 = positionedSet2.circle,\n                            overlap2 = overlapping[positionedSet2.sets[0]],\n                            distance2 = getDistanceBetweenCirclesByOverlap(radius,\n                            positionedCircle2.r,\n                            overlap2);\n                        // Add intersections to list of coordinates.\n                        possibleCoordinates = possibleCoordinates.concat(getCircleCircleIntersection({\n                            x: positionedCircle.x,\n                            y: positionedCircle.y,\n                            r: distance\n                        }, {\n                            x: positionedCircle2.x,\n                            y: positionedCircle2.y,\n                            r: distance2\n                        }));\n                    });\n                    // Iterate all suggested coordinates and find the best one.\n                    possibleCoordinates.forEach(function (coordinates) {\n                        circle.x = coordinates.x;\n                        circle.y = coordinates.y;\n                        // Calculate loss for the suggested coordinates.\n                        var currentLoss = loss(mapOfIdToCircles,\n                            relationsWithTwoSets);\n                        // If the loss is better, then use these new coordinates\n                        if (currentLoss < best.loss) {\n                            best.loss = currentLoss;\n                            best.coordinates = coordinates;\n                        }\n                    });\n                    // Return resulting coordinates.\n                    return best;\n                }, {\n                    loss: Number.MAX_VALUE,\n                    coordinates: void 0\n                });\n                // Add the set to its final position.\n                positionSet(set, bestPosition.coordinates);\n            });\n            // Return the positions of each set.\n            return mapOfIdToCircles;\n        }\n        /**\n         * Calculates the difference between the desired overlap and the actual\n         * overlap between two circles.\n         * @private\n         * @param {Dictionary<Highcharts.CircleObject>} mapOfIdToCircle\n         * Map from id to circle.\n         * @param {Array<Highcharts.VennRelationObject>} relations\n         * List of relations to calculate the loss of.\n         * @return {number}\n         * Returns the loss between positions of the circles for the given\n         * relations.\n         */\n        function loss(mapOfIdToCircle, relations) {\n            var precision = 10e10;\n            // Iterate all the relations and calculate their individual loss.\n            return relations.reduce(function (totalLoss, relation) {\n                var loss = 0;\n                if (relation.sets.length > 1) {\n                    var wantedOverlap = relation.value;\n                    // Calculate the actual overlap between the sets.\n                    var actualOverlap = getOverlapBetweenCircles(\n                        // Get the circles for the given sets.\n                        relation.sets.map(function (set) {\n                            return mapOfIdToCircle[set];\n                    }));\n                    var diff = wantedOverlap - actualOverlap;\n                    loss = Math.round((diff * diff) * precision) / precision;\n                }\n                // Add calculated loss to the sum.\n                return totalLoss + loss;\n            }, 0);\n        }\n        /**\n         * Finds an optimal position for a given point.\n         * @todo add unit tests.\n         * @todo add constraints to optimize the algorithm.\n         * @private\n         * @param {Highcharts.NelderMeadTestFunction} fn\n         *        The function to test a point.\n         * @param {Highcharts.NelderMeadPointArray} initial\n         *        The initial point to optimize.\n         * @return {Highcharts.NelderMeadPointArray}\n         *         Returns the opimized position of a point.\n         */\n        function nelderMead(fn, initial) {\n            var maxIterations = 100,\n                sortByFx = function (a,\n                b) {\n                    return a.fx - b.fx;\n            }, pRef = 1, // Reflection parameter\n            pExp = 2, // Expansion parameter\n            pCon = -0.5, // Contraction parameter\n            pOCon = pCon * pRef, // Outwards contraction parameter\n            pShrink = 0.5; // Shrink parameter\n            /**\n             * @private\n             */\n            var weightedSum = function (weight1,\n                v1,\n                weight2,\n                v2) { return v1.map(function (x,\n                i) { return weight1 * x + weight2 * v2[i]; }); };\n            /**\n             * @private\n             */\n            var getSimplex = function (initial) {\n                    var n = initial.length,\n                simplex = new Array(n + 1);\n                // Initial point to the simplex.\n                simplex[0] = initial;\n                simplex[0].fx = fn(initial);\n                // Create a set of extra points based on the initial.\n                for (var i = 0; i < n; ++i) {\n                    var point = initial.slice();\n                    point[i] = point[i] ? point[i] * 1.05 : 0.001;\n                    point.fx = fn(point);\n                    simplex[i + 1] = point;\n                }\n                return simplex;\n            };\n            var updateSimplex = function (simplex,\n                point) {\n                    point.fx = fn(point);\n                simplex[simplex.length - 1] = point;\n                return simplex;\n            };\n            var shrinkSimplex = function (simplex) {\n                    var best = simplex[0];\n                return simplex.map(function (point) {\n                    var p = weightedSum(1 - pShrink,\n                        best,\n                        pShrink,\n                        point);\n                    p.fx = fn(p);\n                    return p;\n                });\n            };\n            var getPoint = function (centroid,\n                worst,\n                a,\n                b) {\n                    var point = weightedSum(a,\n                centroid,\n                b,\n                worst);\n                point.fx = fn(point);\n                return point;\n            };\n            // Create a simplex\n            var simplex = getSimplex(initial);\n            // Iterate from 0 to max iterations\n            for (var i = 0; i < maxIterations; i++) {\n                // Sort the simplex\n                simplex.sort(sortByFx);\n                // Create a centroid from the simplex\n                var worst = simplex[simplex.length - 1];\n                var centroid = getCentroid(simplex);\n                // Calculate the reflected point.\n                var reflected = getPoint(centroid,\n                    worst, 1 + pRef, -pRef);\n                if (reflected.fx < simplex[0].fx) {\n                    // If reflected point is the best, then possibly expand.\n                    var expanded = getPoint(centroid,\n                        worst, 1 + pExp, -pExp);\n                    simplex = updateSimplex(simplex, (expanded.fx < reflected.fx) ? expanded : reflected);\n                }\n                else if (reflected.fx >= simplex[simplex.length - 2].fx) {\n                    // If the reflected point is worse than the second worse, then\n                    // contract.\n                    var contracted = void 0;\n                    if (reflected.fx > worst.fx) {\n                        // If the reflected is worse than the worst point, do a\n                        // contraction\n                        contracted = getPoint(centroid, worst, 1 + pCon, -pCon);\n                        if (contracted.fx < worst.fx) {\n                            simplex = updateSimplex(simplex, contracted);\n                        }\n                        else {\n                            simplex = shrinkSimplex(simplex);\n                        }\n                    }\n                    else {\n                        // Otherwise do an outwards contraction\n                        contracted = getPoint(centroid, worst, 1 - pOCon, pOCon);\n                        if (contracted.fx < reflected.fx) {\n                            simplex = updateSimplex(simplex, contracted);\n                        }\n                        else {\n                            simplex = shrinkSimplex(simplex);\n                        }\n                    }\n                }\n                else {\n                    simplex = updateSimplex(simplex, reflected);\n                }\n            }\n            return simplex[0];\n        }\n        /**\n         * Prepares the venn data so that it is usable for the layout function.\n         * Filter out sets, or intersections that includes sets, that are missing in\n         * the data or has (value < 1). Adds missing relations between sets in the\n         * data as value = 0.\n         * @private\n         * @param {Array<object>} data The raw input data.\n         * @return {Array<object>} Returns an array of valid venn data.\n         */\n        function processVennData(data) {\n            var d = isArray(data) ? data : [];\n            var validSets = d\n                    .reduce(function (arr,\n                x) {\n                    // Check if x is a valid set, and that it is not an duplicate.\n                    if (isValidSet(x) && arr.indexOf(x.sets[0]) === -1) {\n                        arr.push(x.sets[0]);\n                }\n                return arr;\n            }, [])\n                .sort();\n            var mapOfIdToRelation = d.reduce(function (mapOfIdToRelation,\n                relation) {\n                    if (isValidRelation(relation) &&\n                        !relation.sets.some(function (set) {\n                            return validSets.indexOf(set) === -1;\n                    })) {\n                    mapOfIdToRelation[relation.sets.sort().join()] =\n                        relation;\n                }\n                return mapOfIdToRelation;\n            }, {});\n            validSets.reduce(function (combinations, set, i, arr) {\n                var remaining = arr.slice(i + 1);\n                remaining.forEach(function (set2) {\n                    combinations.push(set + ',' + set2);\n                });\n                return combinations;\n            }, []).forEach(function (combination) {\n                if (!mapOfIdToRelation[combination]) {\n                    var obj = {\n                            sets: combination.split(','),\n                            value: 0\n                        };\n                    mapOfIdToRelation[combination] = obj;\n                }\n            });\n            // Transform map into array.\n            return Object\n                .keys(mapOfIdToRelation)\n                .map(function (id) {\n                return mapOfIdToRelation[id];\n            });\n        }\n        /**\n         * Takes two sets and finds the one with the largest total overlap.\n         * @private\n         * @param {Object} a\n         * The first set to compare.\n         * @param {Object} b\n         * The second set to compare.\n         * @return {number}\n         * Returns 0 if a and b are equal, <0 if a is greater, >0 if b is greater.\n         */\n        function sortByTotalOverlap(a, b) {\n            return b.totalOverlap - a.totalOverlap;\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var VennUtils = {\n                geometry: GU,\n                geometryCircles: CU,\n                addOverlapToSets: addOverlapToSets,\n                getCentroid: getCentroid,\n                getDistanceBetweenCirclesByOverlap: getDistanceBetweenCirclesByOverlap,\n                getLabelWidth: getLabelWidth,\n                getMarginFromCircles: getMarginFromCircles,\n                isSet: isSet,\n                layoutGreedyVenn: layoutGreedyVenn,\n                loss: loss,\n                nelderMead: nelderMead,\n                processVennData: processVennData,\n                sortByTotalOverlap: sortByTotalOverlap\n            };\n\n        return VennUtils;\n    });\n    _registerModule(_modules, 'Series/Venn/VennSeries.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Color/Color.js'], _modules['Core/Geometry/CircleUtilities.js'], _modules['Series/DrawPointUtilities.js'], _modules['Core/Geometry/GeometryUtilities.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Series/Venn/VennPoint.js'], _modules['Series/Venn/VennUtils.js'], _modules['Core/Legend/LegendSymbol.js'], _modules['Core/Utilities.js']], function (A, Color, CU, DPU, GU, SeriesRegistry, VennPoint, VennUtils, LegendSymbol, U) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a Venn\n         *  diagram.\n         *\n         *  (c) 2016-2021 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  Layout algorithm by Ben Frederickson:\n         *  https://www.benfrederickson.com/better-venn-diagrams/\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var animObject = A.animObject;\n        var color = Color.parse;\n        var getAreaOfIntersectionBetweenCircles = CU.getAreaOfIntersectionBetweenCircles,\n            getCirclesIntersectionPolygon = CU.getCirclesIntersectionPolygon,\n            isCircle1CompletelyOverlappingCircle2 = CU.isCircle1CompletelyOverlappingCircle2,\n            isPointInsideAllCircles = CU.isPointInsideAllCircles,\n            isPointOutsideAllCircles = CU.isPointOutsideAllCircles;\n        var getCenterOfPoints = GU.getCenterOfPoints;\n        var ScatterSeries = SeriesRegistry.seriesTypes.scatter;\n        var addEvent = U.addEvent,\n            extend = U.extend,\n            isArray = U.isArray,\n            isNumber = U.isNumber,\n            isObject = U.isObject,\n            isString = U.isString,\n            merge = U.merge;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.venn\n         *\n         * @augments Highcharts.Series\n         */\n        var VennSeries = /** @class */ (function (_super) {\n                __extends(VennSeries, _super);\n            function VennSeries() {\n                /* *\n                 *\n                 *  Static Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                _this.data = void 0;\n                _this.mapOfIdToRelation = void 0;\n                _this.options = void 0;\n                _this.points = void 0;\n                return _this;\n                /* eslint-enable valid-jsdoc */\n            }\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            /**\n             * Finds the optimal label position by looking for a position that has a low\n             * distance from the internal circles, and as large possible distane to the\n             * external circles.\n             * @private\n             * @todo Optimize the intial position.\n             * @todo Add unit tests.\n             * @param {Array<Highcharts.CircleObject>} internal\n             * Internal circles.\n             * @param {Array<Highcharts.CircleObject>} external\n             * External circles.\n             * @return {Highcharts.PositionObject}\n             * Returns the found position.\n             */\n            VennSeries.getLabelPosition = function (internal, external) {\n                // Get the best label position within the internal circles.\n                var best = internal.reduce(function (best,\n                    circle) {\n                        var d = circle.r / 2;\n                    // Give a set of points with the circle to evaluate as the best\n                    // label position.\n                    return [\n                        { x: circle.x, y: circle.y },\n                        { x: circle.x + d, y: circle.y },\n                        { x: circle.x - d, y: circle.y },\n                        { x: circle.x, y: circle.y + d },\n                        { x: circle.x, y: circle.y - d }\n                    ]\n                        // Iterate the given points and return the one with the\n                        // largest margin.\n                        .reduce(function (best, point) {\n                        var margin = VennUtils.getMarginFromCircles(point,\n                            internal,\n                            external);\n                        // If the margin better than the current best, then\n                        // update sbest.\n                        if (best.margin < margin) {\n                            best.point = point;\n                            best.margin = margin;\n                        }\n                        return best;\n                    }, best);\n                }, {\n                    point: void 0,\n                    margin: -Number.MAX_VALUE\n                }).point;\n                // Use nelder mead to optimize the initial label position.\n                var optimal = VennUtils.nelderMead(function (p) {\n                        return -(VennUtils.getMarginFromCircles({ x: p[0],\n                    y: p[1] },\n                    internal,\n                    external));\n                }, [best.x, best.y]);\n                // Update best to be the point which was found to have the best margin.\n                best = {\n                    x: optimal[0],\n                    y: optimal[1]\n                };\n                if (!(isPointInsideAllCircles(best, internal) &&\n                    isPointOutsideAllCircles(best, external))) {\n                    // If point was either outside one of the internal, or inside one of\n                    // the external, then it was invalid and should use a fallback.\n                    if (internal.length > 1) {\n                        best = getCenterOfPoints(getCirclesIntersectionPolygon(internal));\n                    }\n                    else {\n                        best = {\n                            x: internal[0].x,\n                            y: internal[0].y\n                        };\n                    }\n                }\n                // Return the best point.\n                return best;\n            };\n            /**\n             * Calulates data label values for a given relations object.\n             *\n             * @private\n             * @todo add unit tests\n             * @param {Highcharts.VennRelationObject} relation A relations object.\n             * @param {Array<Highcharts.VennRelationObject>} setRelations The list of\n             * relations that is a set.\n             * @return {Highcharts.VennLabelValuesObject}\n             * Returns an object containing position and width of the label.\n             */\n            VennSeries.getLabelValues = function (relation, setRelations) {\n                var sets = relation.sets;\n                // Create a list of internal and external circles.\n                var data = setRelations.reduce(function (data,\n                    set) {\n                        // If the set exists in this relation, then it is internal,\n                        // otherwise it will be external.\n                        var isInternal = sets.indexOf(set.sets[0]) > -1;\n                    var property = isInternal ? 'internal' : 'external';\n                    // Add the circle to the list.\n                    data[property].push(set.circle);\n                    return data;\n                }, {\n                    internal: [],\n                    external: []\n                });\n                // Filter out external circles that are completely overlapping all\n                // internal\n                data.external = data.external.filter(function (externalCircle) {\n                    return data.internal.some(function (internalCircle) {\n                        return !isCircle1CompletelyOverlappingCircle2(externalCircle, internalCircle);\n                    });\n                });\n                // Calulate the label position.\n                var position = VennSeries.getLabelPosition(data.internal,\n                    data.external);\n                // Calculate the label width\n                var width = VennUtils.getLabelWidth(position,\n                    data.internal,\n                    data.external);\n                return {\n                    position: position,\n                    width: width\n                };\n            };\n            /**\n             * Calculates the positions, and the label values of all the sets in the\n             * venn diagram.\n             *\n             * @private\n             * @todo Add support for constrained MDS.\n             * @param {Array<Highchats.VennRelationObject>} relations\n             * List of the overlap between two or more sets, or the size of a single\n             * sset.\n             * @return {Highcharts.Dictionary<*>}\n             * List of circles and their calculated positions.\n             */\n            VennSeries.layout = function (relations) {\n                var mapOfIdToShape = {};\n                var mapOfIdToLabelValues = {};\n                // Calculate best initial positions by using greedy layout.\n                if (relations.length > 0) {\n                    var mapOfIdToCircles_1 = VennUtils.layoutGreedyVenn(relations);\n                    var setRelations_1 = relations.filter(VennUtils.isSet);\n                    relations.forEach(function (relation) {\n                        var sets = relation.sets;\n                        var id = sets.join();\n                        // Get shape from map of circles, or calculate intersection.\n                        var shape = VennUtils.isSet(relation) ?\n                                mapOfIdToCircles_1[id] :\n                                getAreaOfIntersectionBetweenCircles(sets.map(function (set) { return mapOfIdToCircles_1[set]; }));\n                        // Calculate label values if the set has a shape\n                        if (shape) {\n                            mapOfIdToShape[id] = shape;\n                            mapOfIdToLabelValues[id] = VennSeries.getLabelValues(relation, setRelations_1);\n                        }\n                    });\n                }\n                return { mapOfIdToShape: mapOfIdToShape, mapOfIdToLabelValues: mapOfIdToLabelValues };\n            };\n            /**\n             * Calculates the proper scale to fit the cloud inside the plotting area.\n             * @private\n             * @todo add unit test\n             * @param {number} targetWidth\n             * Width of target area.\n             * @param {number} targetHeight\n             * Height of target area.\n             * @param {Highcharts.PolygonBoxObject} field\n             * The playing field.\n             * @return {Highcharts.Dictionary<number>}\n             * Returns the value to scale the playing field up to the size of the target\n             * area, and center of x and y.\n             */\n            VennSeries.getScale = function (targetWidth, targetHeight, field) {\n                var height = field.bottom - field.top, // top is smaller than bottom\n                    width = field.right - field.left,\n                    scaleX = width > 0 ? 1 / width * targetWidth : 1,\n                    scaleY = height > 0 ? 1 / height * targetHeight : 1,\n                    adjustX = (field.right + field.left) / 2,\n                    adjustY = (field.top + field.bottom) / 2,\n                    scale = Math.min(scaleX,\n                    scaleY);\n                return {\n                    scale: scale,\n                    centerX: targetWidth / 2 - adjustX * scale,\n                    centerY: targetHeight / 2 - adjustY * scale\n                };\n            };\n            /**\n             * If a circle is outside a give field, then the boundaries of the field is\n             * adjusted accordingly. Modifies the field object which is passed as the\n             * first parameter.\n             * @private\n             * @todo NOTE: Copied from wordcloud, can probably be unified.\n             * @param {Highcharts.PolygonBoxObject} field\n             * The bounding box of a playing field.\n             * @param {Highcharts.CircleObject} circle\n             * The bounding box for a placed point.\n             * @return {Highcharts.PolygonBoxObject}\n             * Returns a modified field object.\n             */\n            VennSeries.updateFieldBoundaries = function (field, circle) {\n                var left = circle.x - circle.r,\n                    right = circle.x + circle.r,\n                    bottom = circle.y + circle.r,\n                    top = circle.y - circle.r;\n                // TODO improve type checking.\n                if (!isNumber(field.left) || field.left > left) {\n                    field.left = left;\n                }\n                if (!isNumber(field.right) || field.right < right) {\n                    field.right = right;\n                }\n                if (!isNumber(field.top) || field.top > top) {\n                    field.top = top;\n                }\n                if (!isNumber(field.bottom) || field.bottom < bottom) {\n                    field.bottom = bottom;\n                }\n                return field;\n            };\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            VennSeries.prototype.animate = function (init) {\n                if (!init) {\n                    var series = this,\n                        animOptions_1 = animObject(series.options.animation);\n                    series.points.forEach(function (point) {\n                        var args = point.shapeArgs;\n                        if (point.graphic && args) {\n                            var attr = {},\n                                animate = {};\n                            if (args.d) {\n                                // If shape is a path, then animate opacity.\n                                attr.opacity = 0.001;\n                            }\n                            else {\n                                // If shape is a circle, then animate radius.\n                                attr.r = 0;\n                                animate.r = args.r;\n                            }\n                            point.graphic\n                                .attr(attr)\n                                .animate(animate, animOptions_1);\n                            // If shape is path, then fade it in after the circles\n                            // animation\n                            if (args.d) {\n                                setTimeout(function () {\n                                    if (point && point.graphic) {\n                                        point.graphic.animate({\n                                            opacity: 1\n                                        });\n                                    }\n                                }, animOptions_1.duration);\n                            }\n                        }\n                    }, series);\n                }\n            };\n            /**\n             * Draw the graphics for each point.\n             * @private\n             */\n            VennSeries.prototype.drawPoints = function () {\n                var series = this, \n                    // Series properties\n                    chart = series.chart,\n                    group = series.group,\n                    points = series.points || [], \n                    // Chart properties\n                    renderer = chart.renderer;\n                // Iterate all points and calculate and draw their graphics.\n                points.forEach(function (point) {\n                    var attribs = {\n                            zIndex: isArray(point.sets) ? point.sets.length : 0\n                        },\n                        shapeArgs = point.shapeArgs;\n                    // Add point attribs\n                    if (!chart.styledMode) {\n                        extend(attribs, series.pointAttribs(point, point.state));\n                    }\n                    // Draw the point graphic.\n                    DPU.draw(point, {\n                        isNew: !point.graphic,\n                        animatableAttribs: shapeArgs,\n                        attribs: attribs,\n                        group: group,\n                        renderer: renderer,\n                        shapeType: shapeArgs && shapeArgs.d ? 'path' : 'circle'\n                    });\n                });\n            };\n            VennSeries.prototype.init = function () {\n                ScatterSeries.prototype.init.apply(this, arguments);\n                // Venn's opacity is a different option from other series\n                delete this.opacity;\n            };\n            /**\n             * Calculates the style attributes for a point. The attributes can vary\n             * depending on the state of the point.\n             * @private\n             * @param {Highcharts.Point} point\n             * The point which will get the resulting attributes.\n             * @param {string} [state]\n             * The state of the point.\n             * @return {Highcharts.SVGAttributes}\n             * Returns the calculated attributes.\n             */\n            VennSeries.prototype.pointAttribs = function (point, state) {\n                var series = this,\n                    seriesOptions = series.options || {},\n                    pointOptions = point && point.options || {},\n                    stateOptions = (state && seriesOptions.states[state]) || {},\n                    options = merge(seriesOptions, { color: point && point.color },\n                    pointOptions,\n                    stateOptions);\n                // Return resulting values for the attributes.\n                return {\n                    'fill': color(options.color)\n                        .brighten(options.brightness)\n                        .get(),\n                    // Set opacity directly to the SVG element, not to pattern #14372.\n                    opacity: options.opacity,\n                    'stroke': options.borderColor,\n                    'stroke-width': options.borderWidth,\n                    'dashstyle': options.borderDashStyle\n                };\n            };\n            VennSeries.prototype.translate = function () {\n                var chart = this.chart;\n                this.processedXData = this.xData;\n                this.generatePoints();\n                // Process the data before passing it into the layout function.\n                var relations = VennUtils.processVennData(this.options.data);\n                // Calculate the positions of each circle.\n                var _a = VennSeries.layout(relations),\n                    mapOfIdToShape = _a.mapOfIdToShape,\n                    mapOfIdToLabelValues = _a.mapOfIdToLabelValues;\n                // Calculate the scale, and center of the plot area.\n                var field = Object.keys(mapOfIdToShape)\n                        .filter(function (key) {\n                        var shape = mapOfIdToShape[key];\n                    return shape && isNumber(shape.r);\n                })\n                    .reduce(function (field, key) {\n                    return VennSeries.updateFieldBoundaries(field, mapOfIdToShape[key]);\n                }, { top: 0, bottom: 0, left: 0, right: 0 }), scaling = VennSeries.getScale(chart.plotWidth, chart.plotHeight, field), scale = scaling.scale, centerX = scaling.centerX, centerY = scaling.centerY;\n                // Iterate all points and calculate and draw their graphics.\n                this.points.forEach(function (point) {\n                    var sets = isArray(point.sets) ? point.sets : [],\n                        id = sets.join(),\n                        shape = mapOfIdToShape[id],\n                        shapeArgs,\n                        dataLabelValues = mapOfIdToLabelValues[id] || {},\n                        dataLabelWidth = dataLabelValues.width,\n                        dataLabelPosition = dataLabelValues.position,\n                        dlOptions = point.options && point.options.dataLabels;\n                    if (shape) {\n                        if (shape.r) {\n                            shapeArgs = {\n                                x: centerX + shape.x * scale,\n                                y: centerY + shape.y * scale,\n                                r: shape.r * scale\n                            };\n                        }\n                        else if (shape.d) {\n                            var d = shape.d;\n                            d.forEach(function (seg) {\n                                if (seg[0] === 'M') {\n                                    seg[1] = centerX + seg[1] * scale;\n                                    seg[2] = centerY + seg[2] * scale;\n                                }\n                                else if (seg[0] === 'A') {\n                                    seg[1] = seg[1] * scale;\n                                    seg[2] = seg[2] * scale;\n                                    seg[6] = centerX + seg[6] * scale;\n                                    seg[7] = centerY + seg[7] * scale;\n                                }\n                            });\n                            shapeArgs = { d: d };\n                        }\n                        // Scale the position for the data label.\n                        if (dataLabelPosition) {\n                            dataLabelPosition.x = centerX + dataLabelPosition.x * scale;\n                            dataLabelPosition.y = centerY + dataLabelPosition.y * scale;\n                        }\n                        else {\n                            dataLabelPosition = {};\n                        }\n                        if (isNumber(dataLabelWidth)) {\n                            dataLabelWidth = Math.round(dataLabelWidth * scale);\n                        }\n                    }\n                    point.shapeArgs = shapeArgs;\n                    // Placement for the data labels\n                    if (dataLabelPosition && shapeArgs) {\n                        point.plotX = dataLabelPosition.x;\n                        point.plotY = dataLabelPosition.y;\n                    }\n                    // Add width for the data label\n                    if (dataLabelWidth && shapeArgs) {\n                        point.dlOptions = merge(true, {\n                            style: {\n                                width: dataLabelWidth\n                            }\n                        }, isObject(dlOptions, true) ? dlOptions : void 0);\n                    }\n                    // Set name for usage in tooltip and in data label.\n                    point.name = point.options.name || sets.join('∩');\n                });\n            };\n            /**\n             * A Venn diagram displays all possible logical relations between a\n             * collection of different sets. The sets are represented by circles, and\n             * the relation between the sets are displayed by the overlap or lack of\n             * overlap between them. The venn diagram is a special case of Euler\n             * diagrams, which can also be displayed by this series type.\n             *\n             * @sample {highcharts} highcharts/demo/venn-diagram/\n             *         Venn diagram\n             * @sample {highcharts} highcharts/demo/euler-diagram/\n             *         Euler diagram\n             * @sample {highcharts} highcharts/series-venn/point-legend/\n             *         Venn diagram with a legend\n             *\n             * @extends      plotOptions.scatter\n             * @excluding    connectEnds, connectNulls, cropThreshold, dragDrop,\n             *               findNearestPointBy, getExtremesFromAll, jitter, label,\n             *               linecap, lineWidth, linkedTo, marker, negativeColor,\n             *               pointInterval, pointIntervalUnit, pointPlacement,\n             *               pointStart, softThreshold, stacking, steps, threshold,\n             *               xAxis, yAxis, zoneAxis, zones, dataSorting, boostThreshold,\n             *               boostBlending\n             * @product      highcharts\n             * @requires     modules/venn\n             * @optionparent plotOptions.venn\n             */\n            VennSeries.defaultOptions = merge(ScatterSeries.defaultOptions, {\n                borderColor: \"#cccccc\" /* Palette.neutralColor20 */,\n                borderDashStyle: 'solid',\n                borderWidth: 1,\n                brighten: 0,\n                clip: false,\n                colorByPoint: true,\n                dataLabels: {\n                    enabled: true,\n                    verticalAlign: 'middle',\n                    formatter: function () {\n                        return this.point.name;\n                    }\n                },\n                /**\n                 * @ignore-option\n                 * @private\n                 */\n                inactiveOtherPoints: true,\n                /**\n                 * @ignore-option\n                 * @private\n                 */\n                marker: false,\n                opacity: 0.75,\n                showInLegend: false,\n                /**\n                 * @ignore-option\n                 *\n                 * @private\n                 */\n                legendType: 'point',\n                states: {\n                    /**\n                     * @excluding halo\n                     */\n                    hover: {\n                        opacity: 1,\n                        borderColor: \"#333333\" /* Palette.neutralColor80 */\n                    },\n                    /**\n                     * @excluding halo\n                     */\n                    select: {\n                        color: \"#cccccc\" /* Palette.neutralColor20 */,\n                        borderColor: \"#000000\" /* Palette.neutralColor100 */,\n                        animation: false\n                    },\n                    inactive: {\n                        opacity: 0.075\n                    }\n                },\n                tooltip: {\n                    pointFormat: '{point.name}: {point.value}'\n                }\n            });\n            return VennSeries;\n        }(ScatterSeries));\n        extend(VennSeries.prototype, {\n            axisTypes: [],\n            directTouch: true,\n            drawLegendSymbol: LegendSymbol.drawRectangle,\n            isCartesian: false,\n            pointArrayMap: ['value'],\n            pointClass: VennPoint,\n            utils: VennUtils\n        });\n        SeriesRegistry.registerSeriesType('venn', VennSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A `venn` series. If the [type](#series.venn.type) option is\n         * not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.venn\n         * @excluding connectEnds, connectNulls, cropThreshold, dataParser, dataURL,\n         *            findNearestPointBy, getExtremesFromAll, label, linecap, lineWidth,\n         *            linkedTo, marker, negativeColor, pointInterval, pointIntervalUnit,\n         *            pointPlacement, pointStart, softThreshold, stack, stacking, steps,\n         *            threshold, xAxis, yAxis, zoneAxis, zones, dataSorting,\n         *            boostThreshold, boostBlending\n         * @product   highcharts\n         * @requires  modules/venn\n         * @apioption series.venn\n         */\n        /**\n         * @type      {Array<*>}\n         * @extends   series.scatter.data\n         * @excluding marker, x, y\n         * @product   highcharts\n         * @apioption series.venn.data\n         */\n        /**\n         * The name of the point. Used in data labels and tooltip. If name is not\n         * defined then it will default to the joined values in\n         * [sets](#series.venn.sets).\n         *\n         * @sample {highcharts} highcharts/demo/venn-diagram/\n         *         Venn diagram\n         * @sample {highcharts} highcharts/demo/euler-diagram/\n         *         Euler diagram\n         *\n         * @type      {number}\n         * @since     7.0.0\n         * @product   highcharts\n         * @apioption series.venn.data.name\n         */\n        /**\n         * The value of the point, resulting in a relative area of the circle, or area\n         * of overlap between two sets in the venn or euler diagram.\n         *\n         * @sample {highcharts} highcharts/demo/venn-diagram/\n         *         Venn diagram\n         * @sample {highcharts} highcharts/demo/euler-diagram/\n         *         Euler diagram\n         *\n         * @type      {number}\n         * @since     7.0.0\n         * @product   highcharts\n         * @apioption series.venn.data.value\n         */\n        /**\n         * The set or sets the options will be applied to. If a single entry is defined,\n         * then it will create a new set. If more than one entry is defined, then it\n         * will define the overlap between the sets in the array.\n         *\n         * @sample {highcharts} highcharts/demo/venn-diagram/\n         *         Venn diagram\n         * @sample {highcharts} highcharts/demo/euler-diagram/\n         *         Euler diagram\n         *\n         * @type      {Array<string>}\n         * @since     7.0.0\n         * @product   highcharts\n         * @apioption series.venn.data.sets\n         */\n        /**\n         * @excluding halo\n         * @apioption series.venn.states.hover\n         */\n        /**\n         * @excluding halo\n         * @apioption series.venn.states.select\n         */\n        ''; // detach doclets above\n        /* eslint-disable no-invalid-this */\n        // Modify final series options.\n        addEvent(VennSeries, 'afterSetOptions', function (e) {\n            var options = e.options,\n                states = options.states;\n            if (this.is('venn')) {\n                // Explicitly disable all halo options.\n                Object.keys(states).forEach(function (state) {\n                    states[state].halo = false;\n                });\n            }\n        });\n\n        return VennSeries;\n    });\n    _registerModule(_modules, 'masters/modules/venn.src.js', [], function () {\n\n\n    });\n}));"]},"metadata":{},"sourceType":"script","externalDependencies":[]}